---
title: "arima-imputation"
author: "Dylan"
date: "12/27/2020"
output: pdf_document
---

## EDA
```{r}
portScanDf = read.csv("portScan_data2.csv")
```

```{r}
head(portScanDf)
```

```{r}
# hping_ack, hping_fin, hping_xmas have all NaN tcp_options_mss_val
table(portScanDf[is.na(portScanDf$tcp_options_mss_val),]$label)
table(portScanDf$label)
```

```{r}
library(dplyr)
library(hexbin)
require(forecast)
```

```{r}
names(portScanDf)
hist(portScanDf$frame_info_cap_len,col="blue")
barplot(table(portScanDf$label),col="blue")
hist(portScanDf$tcp_len,col="blue")
```

```{r}
table(portScanDf$label)
nrow(portScanDf)
```

```{r}
system.time(plot(hexbin(portScanDf$frame_info_time,portScanDf$frame_info_len),
                 xlab="All Time",
                 ylab="All Frame Length",
                 main="All Frame Length vs. All Time"))
```

```{r}
nmapSynDf = portScanDf %>% filter(portScanDf$label == "11")

system.time(plot(hexbin(nmapSynDf$frame_info_time, nmapSynDf$frame_info_len),
                 xlab="nmap_syn Time",
                 ylab="nmap_syn Frame Length",
                 main="nmap_syn Frame Length vs. nmap_syn Time"))
```

```{r}
zmapDf = portScanDf %>% filter(portScanDf$label == "4")
system.time(plot(hexbin(zmapDf$frame_info_time, zmapDf$frame_info_len),
                 xlab="zmap Time",
                 ylab="zmap Frame Length",
                 main="zmap Frame Length vs. zmap Time"))
```

## ARIMA model to impute missing values in time series
```{r}
# based on prior inspection, imputing ip_id may not be good due to unique ids. 
# quantitative 
# - tcp_options_mss_val
n = length(names(portScanDf))
#names(portScanDf)
names(portScanDf)[c(2,4:5,10,n)]
regDf = portScanDf[!is.na(portScanDf$tcp_options_mss_val),]
xreg = as.matrix(regDf[,names(portScanDf)[c(2,4:5,10,n)]])
model = forecast::auto.arima(regDf$tcp_options_mss_val, 
                             xreg=xreg,max.order=5)

```


```{r}
summary(model)
```

```{r}
library(devtools)
install_github("SteffenMoritz/imputeTS")
```

```{r}
library(imputeTS)
```

```{r}
model2 = na_kalman(portScanDf$tcp_options_mss_val, model = "auto.arima")
```

```{r}
newMssVals = model2
portScanDf$tcp_options_mss_val = newMssVals
head(portScanDf)
```


```{r}
write.csv(portScanDf,"newPortData.csv")
```


```{r}
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("graph")
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("RBGL")
library(pcalg)
library(SMPracticals)

```

```{r}
library(dplyr)
newPortData = read.csv("newPortData.csv")
numericPortData = newPortData %>% select(!(c("X.1","X","frame_info_time_epoch","ip_src","ip_dst")))
```

```{r}
head(numericPortData)
#BiocManager::install("Rgraphviz")
```

```{r}
suffStat = list(C=cor(numericPortData),n=nrow(numericPortData))
pcFit = pc(suffStat, indepTest=gaussCItest, p=ncol(numericPortData),alpha=0.005)
library(Rgraphviz)
plot(pcFit,labels=colnames(numericPortData),main="Inferred DAG for numericPortData")
```

```
It seems that causal structures are identified between ip_checksum and
tcp_options_mss_val. Also between ip_ttl and tcp_options_mss_val. These
structures only assume correctness if we have no unmeasured confounders.
However,  unmeasured confounders are not testable. If we run a randomized
experiment, this can present some semblance of "no unmeasured confounders".
```

```{r}
library(ipw)
weights1 = ipwtm(exposure=label,family='multinomial',
      timevar=frame_info_time, id=ip_id,
      type="first",
      numerator= ~ tcp_len + tcp_flags + tcp_options_mss_val,
      denominator= ~ ip_ttl  + tcp_len + tcp_flags + tcp_options_mss_val,
      data=newPortData)
```
```{r}
library(survey)
msm = (svyglm(label ~ ip_ttl  + tcp_len + tcp_flags + tcp_options_mss_val,
       design = svydesign(~1, weights = ~weights1$ipw.weights, data=newPortData)))
coef(msm)
confint(msm)
```

