---
title: "arima-imputation"
author: "Dylan"
date: "12/27/2020"
output: pdf_document
---

## EDA
```{r}
portScanDf = read.csv("portScan_data2.csv")
```

```{r}
head(portScanDf)
```

```{r}
# hping_ack, hping_fin, hping_xmas have all NaN tcp_options_mss_val
table(portScanDf[is.na(portScanDf$tcp_options_mss_val),]$label)
table(portScanDf$label)
```

```{r}
library(dplyr)
library(hexbin)
require(forecast)
```

```{r}
names(portScanDf)
hist(portScanDf$frame_info_cap_len,col="blue")
barplot(table(portScanDf$label),col="blue")
hist(portScanDf$tcp_len,col="blue")
```

```{r}
table(portScanDf$label)
nrow(portScanDf)
```

```{r}
system.time(plot(hexbin(portScanDf$frame_info_time,portScanDf$frame_info_len),
                 xlab="All Time",
                 ylab="All Frame Length",
                 main="All Frame Length vs. All Time"))
```

```{r}
nmapSynDf = portScanDf %>% filter(portScanDf$label == "11")

system.time(plot(hexbin(nmapSynDf$frame_info_time, nmapSynDf$frame_info_len),
                 xlab="nmap_syn Time",
                 ylab="nmap_syn Frame Length",
                 main="nmap_syn Frame Length vs. nmap_syn Time"))
```

```{r}
zmapDf = portScanDf %>% filter(portScanDf$label == "4")
system.time(plot(hexbin(zmapDf$frame_info_time, zmapDf$frame_info_len),
                 xlab="zmap Time",
                 ylab="zmap Frame Length",
                 main="zmap Frame Length vs. zmap Time"))
```

## ARIMA model to impute missing values in time series
```{r}
# based on prior inspection, imputing ip_id may not be good due to unique ids. 
# quantitative 
# - tcp_options_mss_val
n = length(names(portScanDf))
#names(portScanDf)
names(portScanDf)[c(2,4:5,10,n)]
regDf = portScanDf[!is.na(portScanDf$tcp_options_mss_val),]
xreg = as.matrix(regDf[,names(portScanDf)[c(2,4:5,10,n)]])
model = forecast::auto.arima(regDf$tcp_options_mss_val, 
                             xreg=xreg,max.order=5)

```


```{r}
summary(model)
```

```{r}
library(devtools)
install_github("SteffenMoritz/imputeTS")
```

```{r}
library(imputeTS)
```

```{r}
model2 = na_kalman(portScanDf$tcp_options_mss_val, model = "auto.arima")
```

```{r}
newMssVals = model2
portScanDf$tcp_options_mss_val = newMssVals
head(portScanDf)
```


```{r}
write.csv(portScanDf,"newPortData.csv")
```


```{r}
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("graph")
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("RBGL")
library(pcalg)
library(SMPracticals)

```

```{r}
library(dplyr)
newPortData = read.csv("newPortData.csv")
numericPortData = newPortData %>% select(!(c("X.1","X","frame_info_time_epoch","ip_src","ip_dst")))
```

```{r}
head(numericPortData)
#BiocManager::install("Rgraphviz")
```
## Identifying Causal Structures
```{r}
suffStat = list(C=cor(numericPortData),n=nrow(numericPortData))
pcFit = pc(suffStat, indepTest=gaussCItest, p=ncol(numericPortData),alpha=0.005)
library(Rgraphviz)
plot(pcFit,labels=colnames(numericPortData),main="Inferred DAG for numericPortData")
```

```
It seems that causal structures are identified between ip_checksum and
tcp_options_mss_val. Also between ip_ttl and tcp_options_mss_val. These
structures only assume correctness if we have no unmeasured confounders.
However,  unmeasured confounders are not testable. If we run a randomized
experiment, this can present some semblance of "no unmeasured confounders".
We notice that there are some backdoor paths in the DAG from frame_info_number 
to tcp_len. Conditioning on frame_info_number can block this backdoor path. 
```

```{r}
library(ipw)
weights1 = ipwtm(exposure=label,family='multinomial',
      timevar=frame_info_time, id=ip_id,
      type="first",
      numerator= ~ tcp_len + tcp_flags + tcp_options_mss_val,
      denominator= ~ ip_ttl  + tcp_len + tcp_flags + tcp_options_mss_val,
      data=newPortData)
```

```{r}
library(survey)
msm = (svyglm(label ~ ip_ttl  + tcp_len + tcp_flags + tcp_options_mss_val,
       design = svydesign(~1, weights = ~weights1$ipw.weights, data=newPortData)))
coef(msm)
confint(msm)
```

```{r}
set.seed(402)
library(nnet)
library(dplyr)
require(randomForest)
require(caTools)
fullModelData = numericPortData %>% dplyr::select(!(c("frame_info_time",
                                           "frame_info_number",
                                           "ip_id","ip_flags_df")))
fullModelData$ip_flags = as.factor(fullModelData$ip_flags)
fullModelData$ip_dsfield = as.factor(fullModelData$ip_dsfield)
fullModelData$tcp_flags_fin = as.factor(fullModelData$tcp_flags_fin)
fullModelData$tcp_flags_syn = as.factor(fullModelData$tcp_flags_syn)
fullModelData$tcp_flags_reset = as.factor(fullModelData$tcp_flags_reset)
fullModelData$tcp_flags_push = as.factor(fullModelData$tcp_flags_push)
fullModelData$tcp_flags_ack = as.factor(fullModelData$tcp_flags_ack)
fullModelData$tcp_flags_urg = as.factor(fullModelData$tcp_flags_urg)
fullModelData$tcp_flags_cwr = as.factor(fullModelData$tcp_flags_cwr)
fullModelData$tcp_flags = as.factor(fullModelData$tcp_flags)
fullModelData$label = as.factor(fullModelData$label)
# sample splitting
smp = sample.split(fullModelData$label, SplitRatio = .75)
train = subset(fullModelData, smp == TRUE)
test  = subset(fullModelData, smp == FALSE)

rfProbe = randomForest(label ~ ., data=fullModelData)

```

```{r}
rfProbe
write.csv(fullModelData,"fullProbeData.csv")
library(caret)
varImp(rfProbe)
```

```{r}
#library(tidyverse)
fakeModelData = fullModelData
randomGenCol = function(col,data,isInteger=TRUE) {
   set.seed(402)
   fakeSD = sd(col)
   if (isInteger) {
      return(col+sample(c(0,fakeSD),
             size=nrow(data),replace=TRUE))
   } else {
      return(col+runif(n=nrow(data), min=0,max=fakeSD))
   }
}
categoricalGenCol = function(col,data,isFactor=TRUE) {
   categories = as.list(as.data.frame(table(col)))
   vars = categories$col
   props = categories$Freq/nrow(data)
   if (isFactor) {
      return(as.factor(sample(as.vector(vars), 
                           size=nrow(data),
                           replace=TRUE, 
                           prob = props)))
   } else {
      return(as.integer(sample(as.vector(vars), 
                           size=nrow(data),
                           replace=TRUE, 
                           prob = props)))
   }
}

fakeModelData$fakeFrameInfoLen = randomGenCol(fakeModelData$frame_info_len,fakeModelData)
fakeModelData$fakeFrameInfoCapLen = randomGenCol(fakeModelData$frame_info_cap_len,fakeModelData)
fakeModelData$fakeIPFlags = categoricalGenCol(fakeModelData$ip_flags,fakeModelData)
fakeModelData$fakeIPTTL = randomGenCol(fakeModelData$ip_ttl,fakeModelData)
fakeModelData$fakeIPChecksum = randomGenCol(fakeModelData$ip_checksum,fakeModelData)
fakeModelData$fakeIPLen = randomGenCol(fakeModelData$ip_len,fakeModelData)
fakeModelData$fakeIPDSField = categoricalGenCol(fakeModelData$ip_dsfield, fakeModelData)
fakeModelData$fakeTCPSRCPort = randomGenCol(fakeModelData$tcp_srcport, fakeModelData)
fakeModelData$fakeTCPDSTPort = randomGenCol(fakeModelData$tcp_dstport, fakeModelData)
fakeModelData$fakeTCPSeq = randomGenCol(fakeModelData$tcp_seq, fakeModelData)
fakeModelData$fakeTCPACK = randomGenCol(fakeModelData$tcp_ack, fakeModelData)			
fakeModelData$fakeTCPLen = randomGenCol(fakeModelData$tcp_len, fakeModelData)			
fakeModelData$fakeTCPHDRLen = randomGenCol(fakeModelData$tcp_hdr_len, fakeModelData)			
fakeModelData$fakeTCPFlags = categoricalGenCol(fakeModelData$tcp_flags, fakeModelData)			
fakeModelData$fakeTCPFlagsFin = categoricalGenCol(fakeModelData$tcp_flags_fin, fakeModelData)		
fakeModelData$fakeTCPFlagsSyn = categoricalGenCol(fakeModelData$tcp_flags_syn, fakeModelData)		
fakeModelData$fakeTCPFlagsReset = categoricalGenCol(fakeModelData$tcp_flags_reset, fakeModelData)		
fakeModelData$fakeTCPFlagsPush = categoricalGenCol(fakeModelData$tcp_flags_push, fakeModelData)
fakeModelData$fakeTCPFlagsAck = categoricalGenCol(fakeModelData$tcp_flags_ack,fakeModelData)			
fakeModelData$fakeTCPFlagsUrg = categoricalGenCol(fakeModelData$tcp_flags_urg, fakeModelData)
fakeModelData$fakeTCPFlagsCwr = categoricalGenCol(fakeModelData$tcp_flags_cwr, fakeModelData)
fakeModelData$fakeTCPWindowSize = randomGenCol(fakeModelData$tcp_window_size, fakeModelData)		
fakeModelData$fakeTCPChecksum = randomGenCol(fakeModelData$tcp_checksum, fakeModelData)		
fakeModelData$fakeTCPUrgentPointer = randomGenCol(fakeModelData$tcp_urgent_pointer, fakeModelData)			
fakeModelData$fakeTCPOptionsMSSVal = randomGenCol(fakeModelData$tcp_options_mss_val, fakeModelData, FALSE)

```

```{r}
fakeRFProbe = randomForest(label ~ ., data=fakeModelData)
varImp(fakeRFProbe)

```


```
A few things to note about feature importance changes when
introducing randomly generated columns into the data 
frame is that the feature importances from fake variables
that appear to be drastically lower are from ip_flags,
ip_dsfield, tcp_seq, tcp_flags_fin, tcp_flags_urg, 
and tcp_flags_push. These
attributes seem to indicate that flagging perhaps is 
what could be causing the label to result in 
normal or one of the probing attacks. Xmas sends
packets of with FIN, URG, and PUSH flags "lit up like 
a christmas tree" and other port scanning methods 
use flagging patterns.
```



