---
title: "Feature Importance"
author: "Dylan Chou"
date: "12/27/2020"
output: pdf_document
---

## EDA
```{r}
portScanDf = read.csv("portScan_data2.csv")
```

```{r}
head(portScanDf)
# hping_ack, hping_fin, hping_xmas have all NaN tcp_options_mss_val
table(portScanDf[is.na(portScanDf$tcp_options_mss_val),]$label)
table(portScanDf$label)
```

```{r}
library(dplyr)
library(hexbin)
```

```{r}
names(portScanDf)
hist(portScanDf$frame_info_cap_len,col="blue")
barplot(table(portScanDf$label),col="blue")
hist(portScanDf$tcp_len,col="blue")
```

```{r}
table(portScanDf$label)
nrow(portScanDf)
```

```{r}
system.time(plot(hexbin(portScanDf$frame_info_time,portScanDf$frame_info_len),
                 xlab="All Time",
                 ylab="All Frame Length",
                 main="All Frame Length vs. All Time"))
```

```{r}
nmapSynDf = portScanDf %>% filter(portScanDf$label == "11")

system.time(plot(hexbin(nmapSynDf$frame_info_time, nmapSynDf$frame_info_len),
                 xlab="nmap_syn Time",
                 ylab="nmap_syn Frame Length",
                 main="nmap_syn Frame Length vs. nmap_syn Time"))
```

```{r}
zmapDf = portScanDf %>% filter(portScanDf$label == "4")
system.time(plot(hexbin(zmapDf$frame_info_time, zmapDf$frame_info_len),
                 xlab="zmap Time",
                 ylab="zmap Frame Length",
                 main="zmap Frame Length vs. zmap Time"))
```


```{r}
# 5-10 mins
set.seed(402)
# library(nnet)
library(dplyr)
require(randomForest)
require(caTools)
newPortData = read.csv("newPortData.csv")
numericPortData = newPortData %>% select(!(c("X.1","X","frame_info_time_epoch","ip_src","ip_dst")))

fullModelData = numericPortData %>% dplyr::select(!(c("frame_info_time",
                                           "frame_info_number",
                                           "ip_id","ip_flags_df")))
fullModelData$ip_flags = as.factor(fullModelData$ip_flags)
fullModelData$ip_dsfield = as.factor(fullModelData$ip_dsfield)
fullModelData$tcp_flags_fin = as.factor(fullModelData$tcp_flags_fin)
fullModelData$tcp_flags_syn = as.factor(fullModelData$tcp_flags_syn)
fullModelData$tcp_flags_reset = as.factor(fullModelData$tcp_flags_reset)
fullModelData$tcp_flags_push = as.factor(fullModelData$tcp_flags_push)
fullModelData$tcp_flags_ack = as.factor(fullModelData$tcp_flags_ack)
fullModelData$tcp_flags_urg = as.factor(fullModelData$tcp_flags_urg)
fullModelData$tcp_flags_cwr = as.factor(fullModelData$tcp_flags_cwr)
fullModelData$tcp_flags = as.factor(fullModelData$tcp_flags)
fullModelData$label = as.factor(fullModelData$label)
# sample splitting
smp = sample.split(fullModelData$label, SplitRatio = .75)
train = subset(fullModelData, smp == TRUE)
test  = subset(fullModelData, smp == FALSE)

```

```{r}
library(caret)
subsetModelData = train[sample(nrow(train),nrow(train)*0.10),]
```

```{r}
# rejection method
# create rectangle

fakeModelData = subsetModelData

# Idea: https://web.mit.edu/urban_or_book/www/book/chapter7/7.1.3.html 
rejection_sampling = function(min_x, width, height, f) {
  val = NULL
  while(1){
     rand_y = runif(1,0,1)
     rand_x = runif(1,0,1)
     
     sampled_x = min_x+rand_x*width
     sampled_y = rand_y*height
     density_peak = f(sampled_x)
     if(sampled_y < density_peak){
       val = sampled_x
       break
     }
  }
  return(val)
}

randomGenCol = function(col,data,isInteger=TRUE) {
   set.seed(402)
   min_x = min(col)
   width = max(col)-min(col)
   density_col = density(col)
   f = approxfun(density_col$x, density_col$y)
   height = max(density_col$y)
   vals = c()
   for (i in 1:nrow(data)) {
     if(i%%5000 == 0 && i > 0){
       print(i)
     }
    vals = c(vals,rejection_sampling(min_x, width, height, f))
   }
   return(vals)
}
```

```{r}
categoricalGenCol = function(col,data,isFactor=TRUE) {
   categories = as.list(as.data.frame(table(col)))
   # contains the levels
   vars = categories$col
   props = categories$Freq/nrow(data)
   if (isFactor) {
      return(as.factor(sample(as.vector(vars), 
                           size=nrow(data),
                           replace=TRUE, 
                           prob = props)))
   } else {
      return(as.integer(sample(as.vector(vars), 
                           size=nrow(data),
                           replace=TRUE, 
                           prob = props)))
   }
}

```

```{r}

fakeModelData$fakeFrameInfoLen = randomGenCol(fakeModelData$frame_info_len,fakeModelData)
fakeModelData$fakeFrameInfoCapLen = randomGenCol(fakeModelData$frame_info_cap_len,fakeModelData)
fakeModelData$fakeIPFlags = categoricalGenCol(fakeModelData$ip_flags,fakeModelData)
fakeModelData$fakeIPTTL = randomGenCol(fakeModelData$ip_ttl,fakeModelData)
fakeModelData$fakeIPChecksum = randomGenCol(fakeModelData$ip_checksum,fakeModelData)
fakeModelData$fakeIPLen = randomGenCol(fakeModelData$ip_len,fakeModelData)
fakeModelData$fakeIPDSField = categoricalGenCol(fakeModelData$ip_dsfield, fakeModelData)
fakeModelData$fakeTCPSRCPort = randomGenCol(fakeModelData$tcp_srcport, fakeModelData)
fakeModelData$fakeTCPDSTPort = randomGenCol(fakeModelData$tcp_dstport, fakeModelData)
fakeModelData$fakeTCPSeq = randomGenCol(fakeModelData$tcp_seq, fakeModelData)
fakeModelData$fakeTCPACK = randomGenCol(fakeModelData$tcp_ack, fakeModelData)			
fakeModelData$fakeTCPLen = randomGenCol(fakeModelData$tcp_len, fakeModelData)			
fakeModelData$fakeTCPHDRLen = randomGenCol(fakeModelData$tcp_hdr_len, fakeModelData)			
fakeModelData$fakeTCPFlags = categoricalGenCol(fakeModelData$tcp_flags, fakeModelData)			
fakeModelData$fakeTCPFlagsFin = categoricalGenCol(fakeModelData$tcp_flags_fin, fakeModelData)		
fakeModelData$fakeTCPFlagsSyn = categoricalGenCol(fakeModelData$tcp_flags_syn, fakeModelData)		
fakeModelData$fakeTCPFlagsReset = categoricalGenCol(fakeModelData$tcp_flags_reset, fakeModelData)		
fakeModelData$fakeTCPFlagsPush = categoricalGenCol(fakeModelData$tcp_flags_push, fakeModelData)
fakeModelData$fakeTCPFlagsAck = categoricalGenCol(fakeModelData$tcp_flags_ack,fakeModelData)			
fakeModelData$fakeTCPFlagsUrg = categoricalGenCol(fakeModelData$tcp_flags_urg, fakeModelData)
fakeModelData$fakeTCPFlagsCwr = categoricalGenCol(fakeModelData$tcp_flags_cwr, fakeModelData)
fakeModelData$fakeTCPWindowSize = randomGenCol(fakeModelData$tcp_window_size, fakeModelData)		
fakeModelData$fakeTCPChecksum = randomGenCol(fakeModelData$tcp_checksum, fakeModelData)		
fakeModelData$fakeTCPUrgentPointer = randomGenCol(fakeModelData$tcp_urgent_pointer, fakeModelData)			
fakeModelData$fakeTCPOptionsMSSVal = randomGenCol(fakeModelData$tcp_options_mss_val, fakeModelData, FALSE)

```

```{r}
fakeModelData = fakeModelData[ , grepl( "fake" , colnames(fakeModelData) ) ]
```

```{r}
fakeModelData$label = subsetModelData$label
```

```{r}
# 
RFProbe = rfsrc(label ~ ., data=subsetModelData)
fakeRFProbe = rfsrc(label ~ ., data=fakeModelData)

```

```{r}
require(parallel)
require(data.tree)
require(DiagrammeR)
require(randomForestSRC)
```

```{r}
varImp(RFProbe)
varImp(fakeRFProbe)
```

```
A few things to note about feature importance changes when
introducing randomly generated columns into the data 
frame is that the feature importances from fake variables
that appear to be drastically lower are from
ip_dsfield, tcp_seq, tcp_flags_fin, tcp_flags_urg, tcp_flags,
TCPFlagsCwr, and tcp_flags_push. These
attributes seem to indicate that flagging perhaps is 
what could be causing the label to result in 
normal or one of the probing attacks. Xmas sends
packets of with FIN, URG, and PUSH flags "lit up like 
a christmas tree" and other port scanning methods 
use flagging patterns.
```



